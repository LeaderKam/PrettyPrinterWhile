/*
 * generated by Xtext 2.19.0
 */
package prettyCompilation.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.List
import java.util.LinkedList
import prettyCompilation.wh.Program
import prettyCompilation.wh.Function
import prettyCompilation.wh.Read
import prettyCompilation.wh.Commands
import prettyCompilation.wh.Command
import prettyCompilation.wh.Nop
import prettyCompilation.wh.If
import prettyCompilation.wh.Affectation
import prettyCompilation.wh.While
import prettyCompilation.wh.For
import prettyCompilation.wh.Foreach
import prettyCompilation.wh.Expr
import prettyCompilation.wh.Write
import prettyCompilation.generator.FunctionTable
import java.util.Map
import java.util.HashMap

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhGenerator extends AbstractGenerator {

	String currentName;
	FunctionTable functionTable;
	boolean code = false;
	RegisterList registresAff = new RegisterList("aff");
	RegisterStack registresExpr = new RegisterStack("expr");
	RegisterStack registresI = new RegisterStack("i");
	RegisterStack registresLoop = new RegisterStack("loop");
	RegisterStack registresArgs = new RegisterStack("args");
	public String outputClassname;
	public String indent = "  ";
	public Map<String,Integer> paramsFonctions= new HashMap<String,Integer>();

	/** Instance unique pré-initialisée */
	public static FunctionTable INSTANCE = new FunctionTable();

	List<String> errorList = new LinkedList<String>();

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		doGenerate(resource, fsa, context, "", false)
	}

	def doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context, String output, boolean codep) {
		code = codep;
		// recup table des symboles
		functionTable = INSTANCE;
		for (program : resource.allContents.toIterable.filter(typeof(Program))) {
			program.compile
//			if (!errorList.isEmpty) {
//				System.err.println("Compilation errors :");
//				for (String issue : errorList) {
//					System.err.println(issue);
//				}
//				return;
//			}
			if (code) {
				if (output != "") {
					fsa.generateFile(output.toFirstUpper, compile3addr)
				} else {
					for (f : functionTable.getFunctions()) {
						println("Code 3 adresses de " + f + " :")
						for (instruction : functionTable.getInstructions(f)) {
							println(instruction.toString())
						}
						println("------------------")
					}
				}
			} else {

				fsa.generateFile(output.toFirstUpper, compileToJava(output));

			}

//			if (output.equals("")) {
//				println(compileToJava)
//			} else
//				fsa.generateFile(output, compileToJava);
			for (function : functionTable.getFunctions) {
				var inputs = functionTable.getInputs(function).toString().substring(1)
				inputs = inputs.substring(0, inputs.length - 1)
				fsa.generateFile("temp/" + function + ".txt", inputs)
				fsa.generateFile("temp1/test.text",paramsFonctions.toString);
			}

		}
	}

	def compile3addr() '''
		«FOR f : functionTable.getFunctions()»
			«"Code 3 adresses de "» «f»:
			«FOR instruction : functionTable.getInstructions(f)» 
				«instruction.toString»
			«ENDFOR»
			************------------------************	
		«ENDFOR»	
	'''

	def compile(Program p) {
		for (function : p.functions) {
			currentName = function.name;
			// Création dans la table des fonctions
			functionTable.addFunction(function.name, function.definition.read.variable.size,
				function.definition.write.variable.size)
			function.definition.read.compile

		}
		for (function : p.functions) {
			currentName = function.name;
			function.compile
		}

	}

	def compile(Function f) {
		// prélude
		functionTable.addThreeAddrInstruction(currentName,
			new Code3Adresse("array", registresAff.getPrefixe(), null, null))
		functionTable.addThreeAddrInstruction(currentName,
			new Code3Adresse("array", registresExpr.getPrefixe(), null, null))
		functionTable.addThreeAddrInstruction(currentName,
			new Code3Adresse("array", registresI.getPrefixe(), null, null))
		functionTable.addThreeAddrInstruction(currentName,
			new Code3Adresse("array", registresLoop.getPrefixe(), null, null))
		functionTable.addThreeAddrInstruction(currentName,
			new Code3Adresse("array", registresArgs.getPrefixe(), null, null))
		functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("array", "whileVar", null, null))
		functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("array", "out", null, null))

		f.definition.commands.compile
		f.definition.write.compile
		// postlude
		functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("ret", "out", null, null))

	}

	def compile(Read r) {
		for (v : r.variable) {
			functionTable.addInput(currentName, v.toString())
		}
	}

	def compile(Commands c) {
		for (command : c.commands) {
			command.compile
		}

	}

	def compile(Command c) {
		if (c.command instanceof Nop)
			(c.command as Nop).compile
		else if (c.command instanceof If)
			(c.command as If).compile
		else if (c.command instanceof Affectation)
			(c.command as Affectation).compile
		else if (c.command instanceof While)
			(c.command as While).compile
		else if (c.command instanceof For)
			(c.command as For).compile
		else if (c.command instanceof Foreach)
			(c.command as Foreach).compile
	}

	def compile(Nop w) {
		functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("nop", null, null, null))
	}

	def compile(While w) {
		var name = w.expr.compile
		functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("while", null, name, null))
		w.commands.compile
		functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("aff", name, w.expr.compile, null))
		functionTable.popFromInstructionList(currentName)
	}

	def compile(If i) {
		functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("if", null, i.expr.compile, null))
		i.commands1.compile
		functionTable.popFromInstructionList(currentName)
		if (i.commands2 !== null) {
			i.commands2.compile
		}
		functionTable.popFromInstructionList(currentName)
	}

	def compile(Affectation a) {
		// TODO : Controle du nombre d'affectation pour l'instant c'est 1 := 1
		// Mais pb si on utilise des fonction qui retournent plusieurs param : X,Y := (f1 A) //si f1 retourne plusieurs params
		// TODO : presence de la variable ou pas
		for (v : a.affectations) {
			if (!functionTable.varExists(currentName, v)) {
				functionTable.addVariable(currentName, v);
			}
		}
		for (expr : a.valeurs) {
			// r =  cons nil ?
			// TO DO : création de variable par push/pop direct
			functionTable.addThreeAddrInstruction(currentName,
				new Code3Adresse("aff", registresAff.push, expr.compile, null))
		}
		for (v : a.affectations) {
			// r = cons nil ?
			if (registresAff.isEmpty()) {
				errorList.add("[ERROR]Too many values at the left side of the affectation")
				return
			}
			functionTable.addThreeAddrInstruction(currentName,
				new Code3Adresse("aff", functionTable.getVariable(currentName, v), registresAff.pop(), null))
		}
		if (!registresAff.isEmpty()) {
			errorList.add("[ERROR]Too many values at the right side of the affectation")
			while (!registresAff.isEmpty())
				registresAff.pop
			return
		}
	}

	def compile(For f) {
		var name = f.expr.compile
		functionTable.addThreeAddrInstruction(currentName,
			new Code3Adresse("for", registresLoop.push, name, registresI.push))
		f.commands.compile
		functionTable.popFromInstructionList(currentName)
		registresI.pop()
		registresLoop.pop
	}

	def compile(Foreach f) {
		if (!functionTable.varExists(currentName, f.variable)) {
			functionTable.addVariable(currentName, f.variable)
		}
		functionTable.addThreeAddrInstruction(currentName,
			new Code3Adresse("foreach", registresExpr.push, f.expr.compile,
				functionTable.getVariable(currentName, f.variable)))
		f.commands.compile
		functionTable.popFromInstructionList(currentName)
		registresExpr.pop
	}

	def compile(Write w) {
		for (v : w.variable) {
			if (!functionTable.varExists(currentName, v)) {
				functionTable.addThreeAddrInstruction(currentName,
					new Code3Adresse("nil", functionTable.getVariable(currentName, v), null, null))
			}
			functionTable.addThreeAddrInstruction(currentName,
				new Code3Adresse("push", "out", functionTable.getVariable(currentName, v), null))
		}
	}
	
	

	def compileToJava(String output) '''
		package compilation;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import compilation.Libwh;
		import compilation.BinTree;
		import java.util.function.Function;
		import javax.script.*;
		import java.util.HashMap;
		import java.util.Map;
		
		
		public class «output.replace(".java","").toFirstUpper» {
			public static Libwh libwh = new Libwh();
			public static Map<String,Integer> paramsFunctions= new HashMap<String,Integer>();
		«indent»«FOR f : functionTable.getFunctions()»
			«indent»	public static List<BinTree> «f»(«FOR read : functionTable.getInputs(f) SEPARATOR ', '»BinTree «functionTable.getVariable(f, read) »«ENDFOR»){
					«FOR instruction:functionTable.getInstructions(f)»
						«instruction.compile()»
						
					«ENDFOR»
					«paramsFonctions.put(f,functionTable.getInputs(f).size())»
			«indent»	}
			«ENDFOR»
			public static void main(String[] args){
				«FOR function: functionTable.getFunctions()»
					
				«ENDFOR»
				if(args.length>0){	
					if(args.length==1){
						BinTree paramX= libwh.bintreeFromString(args[0]);
						System.out.println("ToString binTree : "+libwh.bintreeToString(paramX));
					}else{	
						for(int i=0;i<args.length ;i++){
							System.out.println("Params:  "+args[i]);
						//for(int i=0;i<args.length -1<i++){
						//	BinTree "param"+(i+1)= libwh.bintreeFromString(args[1]);
						}
						BinTree paramX= libwh.bintreeFromString(args[1]);
						BinTree paramY= libwh.bintreeFromString(args[2]);
						System.out.println("ToString binTree : "+libwh.bintreeToString(paramX));
				
						List<BinTree> a=f1(paramX, paramY);
						System.out.println("Int of BinTree : "+libwh.intFromBintree(a.get(0)));	
					}			
				}else{
					System.out.println("pas*********");
						
				}
			}
		}
	'''

// return le nom de la variable
// génère du code 3@
// Remplacer par un switch ?
	def String compile(Expr e) {
		if (e.valeur !== null) {
			if (e.valeur.equals("nil")) {
				// attention c'est du fifo
				// peut etre à changer en stack si besoin pour les autres Expr...
				functionTable.addThreeAddrInstruction(currentName,
					new Code3Adresse("nil", registresExpr.push, null, null))
				return registresExpr.pop;
			} // VARIABLES
			else {
				// TODO  controler la présence de la variable dans la liste des variable,
				// Si elle n'existe pas on fait quoi ?
				// +différence VARIABLE vs SYMBOLE ??
				return functionTable.getVariable(currentName, e.valeur);
			}
//		} // SYMBOLES
//		else if (e.symb !== null) {
//			if (!functionTable.varExists(currentName, e.symb)) {
//				functionTable.addVariable(currentName, e.symb);
//			}
//			functionTable.addThreeAddrInstruction(currentName,
//				new Code3Adresse("symb", functionTable.getVariable(currentName, e.symb), e.symb, null))
//			return functionTable.getVariable(currentName, e.symb);
//		} else if (e.ope.equals("cons")) {
//			var name = registresExpr.push;
//			functionTable.addThreeAddrInstruction(currentName,
//				new Code3Adresse("aff", name, e.lexpr.exprs.reverseView.remove(0).compile, null))
//			for (expr : e.lexpr.exprs.reverseView) {
//				functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("cons", name, expr.compile, name))
//			}
//			return registresExpr.pop;
		} else if (e.ope.equals("list")) {
			var name = registresExpr.push;
			functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("nil", name, null, null))
			for (expr : e.lexpr.exprs.reverseView) {
				functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("cons", name, expr.compile, name))
			}
			return registresExpr.pop;
		} else if (e.ope.equals("hd") || e.ope.equals("tl") || e.ope.equals("not")) {
			var name = registresExpr.push;
			functionTable.addThreeAddrInstruction(currentName, new Code3Adresse(e.ope, name, e.expr.compile, null))
			return registresExpr.pop;
		} else if (e.ope.equals("and") || e.ope.equals("or") || e.ope.equals("=?")) {
			var name = registresExpr.push;
			functionTable.addThreeAddrInstruction(currentName,
				new Code3Adresse(e.ope, name, e.ex1.compile, e.ex2.compile))
			return registresExpr.pop;
		} // TODO else --> call
		else {
			if (!functionTable.functionExists(e.ope)) {
				errorList.add("[ERROR]the function named \"" + e.ope + "\" doesn't exist")
				return "null"
			}
			if (functionTable.getInputs(e.ope).size != e.lexpr.exprs.size) {
				errorList.add(
					"[ERROR]the function named \"" + e.ope + "\" have " + functionTable.getInputs(e.ope).size +
						" parameters and not " + e.lexpr.exprs.size)
				return "null"
			}
			if ((e.eContainer instanceof Affectation) || functionTable.getOutput(e.ope) == 1) {
				var name = registresExpr.push;
				var args = registresArgs.push
				functionTable.addThreeAddrInstruction(currentName, new Code3Adresse("subarray", args, null, null))
				for (expr : e.lexpr.exprs) {
					functionTable.addThreeAddrInstruction(currentName,
						new Code3Adresse("push", args, expr.compile, null))
				}
				functionTable.addThreeAddrInstruction(currentName,
					new Code3Adresse("call", e.ope, registresArgs.pop, registresExpr.pop))
				// le premier
				functionTable.addThreeAddrInstruction(currentName,
					new Code3Adresse("pop", registresExpr.push, name, null))
//				// cas affectation (sauf le premier)
//				if (functionTable.getOutput(e.ope) > 1) {
//					var i = 0
//					for (i = 0; i < functionTable.getOutput(e.ope) - 1; i++) {
//						// 3@ pop
//						functionTable.addThreeAddrInstruction(currentName,
//							new Code3Adresse("pop", registresExpr.push, name, null))
//						// 3@ aff -> aff.push 
//						functionTable.addThreeAddrInstruction(currentName,
//							new Code3Adresse("aff", registresAff.push, registresExpr.pop, null))
//					}
//				}

				return registresExpr.pop;

			} else {

				errorList.add("[ERROR]the function named \"" + e.ope + "\" has more than one returned value")
				return "null"
			}
		}
	}
}
